"""
Oracle Signature Verification Test

This script demonstrates how to verify cryptographic signatures generated by the
AI Oracle Content Moderation API. It simulates the verification process that
would be performed by smart contracts on the blockchain.

The verification process ensures that:
1. The content was approved by the trusted oracle
2. The signature is mathematically valid
3. The signature was created by the expected oracle address

Usage:
    python verify_test.py
    
Author: AI Oracle Content Moderation System
Version: 1.0.0
"""

import sys
from eth_account import Account
from eth_account.messages import encode_defunct

# Test Configuration
# =================
# Note: These values should match exactly what was sent to and returned by the API

# The original text content that was submitted for moderation
REPORT_TEXT = "The officer handling this complaint was rude."

# The signature returned by the moderation API for approved content
# This is a 130-character hexadecimal string (65 bytes)
API_SIGNATURE = "478d7ca9175e4a178f943b53a27076b6794f65d4ca30eeb5466b497cddd60d713ef98e62aa5106e5fa6253af1e2f9d32e7cee9b7f3590df1a3ddaaedf81c93af1b"

# The oracle address returned by the moderation API
# This should match the public address derived from the oracle's private key
EXPECTED_ORACLE_ADDRESS = "0x1C93d0A8ab65f251E11786783cde3370Ff1CBc47"


def verify_signature(text: str, signature: str, expected_address: str) -> bool:
    """
    Verify an oracle signature using Ethereum cryptographic standards.
    
    This function replicates the verification process that would be performed
    by smart contracts to validate oracle signatures.
    
    Args:
        text: The original text content that was signed
        signature: Hexadecimal signature string from the oracle
        expected_address: Expected Ethereum address of the oracle
        
    Returns:
        bool: True if signature is valid and from expected oracle, False otherwise
        
    Raises:
        ValueError: If signature format is invalid
        Exception: If verification process fails
    """
    try:
        # Step 1: Reconstruct the message hash
        # The oracle uses Ethereum's EIP-191 standard message format
        # This adds a prefix to prevent signature replay attacks
        message = encode_defunct(text=text)
        
        # Step 2: Recover the signer's address from the signature
        # This uses elliptic curve cryptography to derive the public key
        # and Ethereum address from the signature and message hash
        recovered_address = Account.recover_message(message, signature=signature)
        
        # Step 3: Verify the address matches the expected oracle
        # Case-insensitive comparison for compatibility
        is_valid = recovered_address.lower() == expected_address.lower()
        
        return is_valid, recovered_address
        
    except ValueError as e:
        print(f"ERROR: Invalid signature format - {e}")
        return False, None
        
    except Exception as e:
        print(f"ERROR: Verification failed - {e}")
        return False, None


def simulate_smart_contract_verification():
    """
    Simulate the verification process that would occur in a smart contract.
    
    This demonstrates how blockchain applications can verify oracle signatures
    to ensure content has been properly moderated before accepting it.
    """
    print("=" * 60)
    print("ORACLE SIGNATURE VERIFICATION TEST")
    print("=" * 60)
    
    print(f"Text Content: '{REPORT_TEXT}'")
    print(f"Signature: {API_SIGNATURE[:20]}...{API_SIGNATURE[-20:]}")
    print(f"Expected Oracle: {EXPECTED_ORACLE_ADDRESS}")
    print()
    
    print("Performing verification...")
    
    # Verify the signature
    is_valid, recovered_address = verify_signature(
        REPORT_TEXT, 
        API_SIGNATURE, 
        EXPECTED_ORACLE_ADDRESS
    )
    
    # Display results
    if recovered_address:
        print(f"Recovered Address: {recovered_address}")
    
    if is_valid:
        print("\n SUCCESS: The signature is VALID!")
        print("   - The content was signed by the expected oracle")
        print("   - The signature is mathematically correct")
        print("   - Smart contracts can safely accept this content")
        
    else:
        print("\n FAILURE: The signature is INVALID!")
        print("   - The signature may be corrupted")
        print("   - The content may have been modified")
        print("   - The wrong oracle address may have been provided")
        print("   - Smart contracts should REJECT this content")
    
    return is_valid


def test_with_modified_content():
    """
    Demonstrate what happens when content is tampered with.
    
    This shows how signature verification catches attempts to modify
    approved content after it has been signed by the oracle.
    """
    print("\n" + "=" * 60)
    print("TAMPER DETECTION TEST")
    print("=" * 60)
    
    # Modify the original text slightly
    modified_text = "The officer handling this complaint was very rude."  # Added "very"
    
    print(f"Original: '{REPORT_TEXT}'")
    print(f"Modified: '{modified_text}'")
    
    is_valid, recovered_address = verify_signature(
        modified_text,
        API_SIGNATURE, 
        EXPECTED_ORACLE_ADDRESS
    )
    
    if is_valid:
        print("\n UNEXPECTED: Modified content verified (this should not happen)")
    else:
        print("\n SUCCESS: Tampered content was detected and rejected")
        print("   - Signature verification prevents content modification")
        print("   - Blockchain maintains data integrity")


def main():
    """Main test function."""
    try:
        # Run the main verification test
        verification_passed = simulate_smart_contract_verification()
        
        # Demonstrate tamper detection
        test_with_modified_content()
        
        # Final status
        print("\n" + "=" * 60)
        if verification_passed:
            print("TEST SUMMARY: All verifications completed successfully")
            print("The oracle signature system is working correctly")
        else:
            print("TEST SUMMARY: Verification failed")
            print("Please check the signature, content, or oracle address")
        print("=" * 60)
        
        return 0 if verification_passed else 1
        
    except KeyboardInterrupt:
        print("\nTest interrupted by user")
        return 1
        
    except Exception as e:
        print(f"\nUnexpected error during testing: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
